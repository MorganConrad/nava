package com.flyingspaniel.nava.net;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

/**
 * Java Class for doing RFC 2617 Digest Authentication.  Can also fallback and do RFC 2069
 * <p>
 * See http://www.ietf.org/rfc/rfc2617.txt and http://en.wikipedia.org/wiki/Digest_access_authentication
 * <p>
 * <b>Note</b>  Though the responses exactly match those in the Wikipedia article and thise
 * generated by Chrome, I never got this to actually work on test servers such as httpbin.org.
 * So I cannot guarantee that this will actually work in a real environment.  Help!
 *
 * @author Morgan Conrad
 * @see <a href="http://opensource.org/licenses/MIT">This software is released under the MIT License</a>
 * @since Copyright (c) 2013 by Morgan Conrad
 *
 * Some ideas borrowed from  https://gist.github.com/slightfoot/5624590
 */
public class JRFC2617 {

   public static final String DIGEST = "Digest";

   static final char[] HEX = "0123456789abcdef".toCharArray();
   static final String QUOTE = "\"";
   static final String AUTHORIZATION = "Authorization";
   static final String MD5 = "MD5";

   public enum Key  {
      username(true),
      realm(true),
      nonce(true),
      uri(true),
      qop(false),
      nc(false),
      cnonce(true),
      response(true),
      opaque(true);

      final public boolean isQuoted;

      Key(boolean isQuoted) { this.isQuoted = isQuoted; }

      // a few keys which don't get sent back, so aren't in the enums
      public static final String algorithm = "algorithm";
      public static final String method = "method";
      public static final String stale = "stale";
   }

   static final String NC_X = "00000000";

   protected int nonceCount = 0;
   protected final Map<String,String> crMap;
   protected final MessageDigest messageDigest;
   protected final Random random;
   protected String fullResponse = null;
   protected URL failedURL = null;


   /**
    * Constructor
    * @param challenge should begin with "Digest"
    */
   public JRFC2617(String challenge) {
      crMap = createChallengeMap(challenge);
      String algo = crMap.get(Key.algorithm);
      if (algo.startsWith(MD5))  // same for MD5 sess
         algo = MD5;
      messageDigest = createMessageDigest(algo);
      random = new Random();
   }


   /**
    * Alternative Constructor
    * @param failedWith401 the connection that gave you a 401
    */
   public JRFC2617(HttpURLConnection failedWith401) {
      this(failedWith401.getHeaderField("WWW-Authenticate"));

      failedURL = failedWith401.getURL();
      crMap.put(Key.method, failedWith401.getRequestMethod());
   }


   /**
    * Create the response credentials
    * @param username non-null username
    * @param password non-null password
    * @param cnonce   may be null, typical, in which case one will be created
    * @param method   non-null
    * @param uri      non-null
    * @return         the response, excluding the leading "Digest "
    */
   public String createResponse(String username, String password, String cnonce, String method, String uri) {

      if (cnonce == null)
         cnonce = createCnonce();

      String HA1 = MD5(username, getChallenge(Key.realm), password);
      String HA2 = MD5(method, uri);
      String response;

      crMap.put(Key.username.name(), username);
      crMap.put(Key.uri.name(), uri);

      boolean fallbackToRFC2069 = getChallenge(Key.qop).length() == 0;
      if (fallbackToRFC2069) {
         response = MD5(HA1, getChallenge(Key.nonce), HA2);
      }
      else {
         String nc = createNonceCountString(++nonceCount);
         crMap.put(Key.nc.name(), nc);
         crMap.put(Key.cnonce.name(), cnonce);
         response = MD5(HA1, getChallenge(Key.nonce), nc, cnonce, getChallenge(Key.qop), HA2);
      }

      crMap.put(Key.response.name(), response);

      StringBuilder sb = new StringBuilder();

      for (Key key : Key.values()) {

         String val = getChallenge(key);
         if (val != null) {
            if (sb.length() > 0)
               sb.append(", ");

            String q = key.isQuoted ? QUOTE : "";
            sb.append(key.name() + "=");
            sb.append(q + val + q);
         }
      }

      fullResponse =  sb.toString();
      return fullResponse;
   }


   /**
    * This method only works after the failedWith401 style constructor
    * @param   username
    * @param   password
    * @return  a new HTTPConnection with the "Authorization" header set
    * @throws IOException
    */
   public HttpURLConnection createRetryConnection(String username, String password) throws IOException {

      String cnonce = createCnonce();
      String uri = failedURL.getPath();
      String method = crMap.get(Key.method);
      createResponse(username, password, cnonce, method, uri);

      HttpURLConnection retry = (HttpURLConnection)failedURL.openConnection();
      this.applyToConnection(retry);

      return retry;
   }


   /**
    * Convenience method to put the repsonse in the connection
    * @param conn
    */
   public void applyToConnection(URLConnection conn) {
      if (fullResponse == null)
         throw new IllegalStateException();
      conn.addRequestProperty(AUTHORIZATION, DIGEST + " " + fullResponse);
   }


   /**
    * Makes the MD5 of arg[0]:arg[1]:arg[2]...
    * @param args
    * @return
    */
   public String MD5(String...args) {
      String joined;
      if (args.length == 1)
          joined = args[0];
      else {
         StringBuilder join = new StringBuilder();
         for (String arg : args) {
            join.append(":");
            if (arg == null)
               throw new IllegalStateException();
            join.append(arg);
         }
         joined = join.substring(1); // remove leading ":"
      }

      byte[] digest = new byte[0];
      synchronized (messageDigest) {
         digest = messageDigest.digest(joined.getBytes());
      }

      return encode16to32(digest);
   }


   /**
    * Unquote a String, removing leading and trailing "
    * @param in
    * @return
    */
   public String unq(String in) {
      if (in.startsWith(QUOTE))
         return in.substring(1, in.length()-1);

      return in;
   }


   /**
    * Represent the MD5 digest as Hex.  See http://www.ietf.org/rfc/rfc2617.txt  section 3.1.3
    * @param digest 16 chars
    * @return       32 char String
    */
   public String encode16to32(byte[] digest) {

      if (digest.length != 16) {
         throw new IllegalStateException();
      }

      char[] buffer = new char[32];
      int cIdx = 0;
      for (byte b : digest) {
         int low = (int) (b & 0x0f);
         int high = (int) ((b & 0xf0) >> 4);
         buffer[cIdx++] = HEX[high];
         buffer[cIdx++] = HEX[low];
      }

      return new String(buffer);
   }


   /**
    * Create a cnonce.  Subclasses requireing more security may want to override
    * @return
    */
   protected String createCnonce() {
      long aLong = random.nextLong() ^ System.currentTimeMillis();
      return MD5(Long.toString(aLong));
   }




   protected Map<String,String> createChallengeMap(String challenge) {
      int digestIdx = challenge.indexOf(DIGEST);
      if (digestIdx < 0)
         throw new IllegalStateException("Not Digest Authentication: " + challenge);
      challenge = challenge.substring(digestIdx + DIGEST.length());
      Map<String,String> cMap =  new LinkedHashMap<String,String>();

      cMap.put(Key.algorithm, MD5);  // defaults
      cMap.put(Key.qop.name(), "");
      cMap.put(Key.stale, "false");

      String[] splitOnComma = challenge.split(", ");
      for (String s : splitOnComma) {
         s = s.trim();
         String[] split2 = s.split("=");
         cMap.put(split2[0], unq(split2[1]));
      }

      // special check for qop
      String qopS = cMap.get(Key.qop.name());
      if (qopS.length() > 0) {
         if ("auth".equals(qopS) || qopS.contains("auth,"))
            cMap.put(Key.qop.name(), "auth");
         else
            throw new UnsupportedOperationException("qop must be none or auth");
      }

      return cMap;
   }

   protected String getChallenge(Key key) {
      return crMap.get(key.name());
   }

   protected MessageDigest createMessageDigest(String algo) {
      try {
         return MessageDigest.getInstance(algo);
      } catch (NoSuchAlgorithmException e) {
         throw new IllegalArgumentException("not a valid algorithm: " + algo, e);
      }
   }

   protected String createNonceCountString(int count) {
      String sI = Integer.toHexString(count);
      return NC_X.substring(0, NC_X.length() - sI.length())  + sI;
   }


}
